<link rel="stylesheet" href="css/loader.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.min.js"></script>
<textarea id="expressionInputElement">X^2</textarea>
<br>
Область определений<br> 
от <input type="text" id="xMinTextBox" value="-15">
<br>
до <input type="text" id="xMaxTextBox" value="15">
<br>
с шагом <input type="text" id="xStepTextBox" value="1">
<br>
<button id="drawButton" onclick="draw()">Нарисовать</button>
<br>
<canvas id="myChart" width="400" height="400"></canvas>
<script>
    async function draw()
    {
        let button = document.getElementById("drawButton");
        button.disabled = true;

        let ctx = document.getElementById("myChart");

        let labels = getLabels();

        button.innerHTML = '<div class="loader"></div>';

        let points = await getPoints(labels);
        button.innerHTML = 'Нарисовать';

        let data = {
            //args
            labels: labels,
            datasets: [
            //{
            //    label: "f(x) = x",
            //    function: function (x) { return x },
            //    borderColor: "rgba(75, 192, 192, 1)",
            //    data: [],
            //    fill: false
            //},
            //{
            //    label: "f(x) = x²",
            //    function: function (x) { return x * x },
            //    borderColor: "rgba(153, 102, 255, 1)",
            //    data: [],
            //    fill: false
            //},
            {
                    label: "mathFunction",
                    function: x => points.filter(p => p.x == x)
                                        .map(p => p.y),
                borderColor: "rgba(255, 206, 86, 1)",
                data: [],
                fill: false
            }]
        };

        Chart.pluginService.register({
            beforeInit: function (chart) {
                let data = chart.config.data;
                for (i = 0; i < data.datasets.length; i++) {
                    for (j = 0; j < data.labels.length; j++) {
                        let fct = data.datasets[i].function,
                            x = data.labels[j],
                            functionValues = fct(x);
                        functionValues.map(y => data.datasets[i].data.push(y));
                    }
                }
            }
        });

        let myBarChart = new Chart(ctx, {
            type: 'line',
            data: data,
            options: {
                scales: {
                    yAxes: [{
                        ticks: {
                            beginAtZero: false
                        }
                    }],
                    xAxes: [{
                        ticks: {
                            beginAtZero: false
                        }
                    }]
                }
            }
        });
        button.disabled = false;
    }

    async function mathFunction(args) {
        let textarea = document.getElementById("expressionInputElement");
        let expression = textarea.value;
        let payloadObject = {
            expression: expression,
            parametersTable: args.map(a => [
                {
                    variableName: "x",
                    value: a
                }
            ])
                
        };
        let response = await fetch('api/math/computeFunctionValues',
        {
            method: "post",
            headers: {
                "content-type": "application/json"
            },
            body: JSON.stringify(payloadObject)
        });

        let jsonResponse = await response.json();

        return jsonResponse.result;
    }

    function getLabels() {

        let xMinTextBox = document.getElementById("xMinTextBox");
        let xMaxTextBox = document.getElementById("xMaxTextBox");
        let xStepTextBox = document.getElementById("xStepTextBox");

        if (!(Number(xMinTextBox.value) != NaN &&
            Number(xMaxTextBox.value) != NaN &&
            Number(xStepTextBox.value) != NaN))
            return [0, 1, 2, 3, 4, 5];

        xMin = Number(xMinTextBox.value);
        xMax = Number(xMaxTextBox.value);
        xStep = Number(xStepTextBox.value);
        result = [];
        for (xMin; xMin < xMax; xMin += xStep)
            result.push(xMin);
        result.push(xMax);

        return result;
    }

    async function getPoints(labels) {
        let computed = await mathFunction(labels);

        let results = computed.map(c => {
            return {
                x: c.parameters[0].value,
                y: c.value
            };
        });

        return results;
    }

</script>